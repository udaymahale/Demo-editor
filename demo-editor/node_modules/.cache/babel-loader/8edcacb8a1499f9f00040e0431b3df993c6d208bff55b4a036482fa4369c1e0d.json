{"ast":null,"code":"/**\n * @license\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport { is } from './is.js';\nimport { Collection, KeyedCollection } from './Collection.js';\nimport { isMap, IS_MAP_SYMBOL } from './predicates/isMap.js';\nimport { isOrdered } from './predicates/isOrdered.js';\nimport { DELETE, NOT_SET, SetRef, MakeRef, MASK, SHIFT, SIZE, OwnerID } from './TrieUtils.js';\nimport { hash } from './Hash.js';\nimport { iteratorDone, Iterator, iteratorValue } from './Iterator.js';\nimport { sortFactory } from './Operations.js';\nimport arrCopy from './utils/arrCopy.js';\nimport assertNotInfinite from './utils/assertNotInfinite.js';\nimport { setIn } from './methods/setIn.js';\nimport { deleteIn } from './methods/deleteIn.js';\nimport { update } from './methods/update.js';\nimport { updateIn } from './methods/updateIn.js';\nimport { merge, mergeWith } from './methods/merge.js';\nimport { mergeDeep, mergeDeepWith } from './methods/mergeDeep.js';\nimport { mergeIn } from './methods/mergeIn.js';\nimport { mergeDeepIn } from './methods/mergeDeepIn.js';\nimport { withMutations } from './methods/withMutations.js';\nimport { asMutable } from './methods/asMutable.js';\nimport { asImmutable } from './methods/asImmutable.js';\nimport { wasAltered } from './methods/wasAltered.js';\nimport { OrderedMap } from './OrderedMap.js';\nvar Map = /*@__PURE__*/function (KeyedCollection) {\n  function Map(value) {\n    return value === undefined || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {\n      var iter = KeyedCollection(value);\n      assertNotInfinite(iter.size);\n      iter.forEach(function (v, k) {\n        return map.set(k, v);\n      });\n    });\n  }\n  if (KeyedCollection) Map.__proto__ = KeyedCollection;\n  Map.prototype = Object.create(KeyedCollection && KeyedCollection.prototype);\n  Map.prototype.constructor = Map;\n  Map.of = function of() {\n    var keyValues = [],\n      len = arguments.length;\n    while (len--) keyValues[len] = arguments[len];\n    return emptyMap().withMutations(function (map) {\n      for (var i = 0; i < keyValues.length; i += 2) {\n        if (i + 1 >= keyValues.length) {\n          throw new Error('Missing value for key: ' + keyValues[i]);\n        }\n        map.set(keyValues[i], keyValues[i + 1]);\n      }\n    });\n  };\n  Map.prototype.toString = function toString() {\n    return this.__toString('Map {', '}');\n  };\n\n  // @pragma Access\n\n  Map.prototype.get = function get(k, notSetValue) {\n    return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;\n  };\n\n  // @pragma Modification\n\n  Map.prototype.set = function set(k, v) {\n    return updateMap(this, k, v);\n  };\n  Map.prototype.remove = function remove(k) {\n    return updateMap(this, k, NOT_SET);\n  };\n  Map.prototype.deleteAll = function deleteAll(keys) {\n    var collection = Collection(keys);\n    if (collection.size === 0) {\n      return this;\n    }\n    return this.withMutations(function (map) {\n      collection.forEach(function (key) {\n        return map.remove(key);\n      });\n    });\n  };\n  Map.prototype.clear = function clear() {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._root = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyMap();\n  };\n\n  // @pragma Composition\n\n  Map.prototype.sort = function sort(comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator));\n  };\n  Map.prototype.sortBy = function sortBy(mapper, comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator, mapper));\n  };\n  Map.prototype.map = function map(mapper, context) {\n    var this$1$1 = this;\n    return this.withMutations(function (map) {\n      map.forEach(function (value, key) {\n        map.set(key, mapper.call(context, value, key, this$1$1));\n      });\n    });\n  };\n\n  // @pragma Mutability\n\n  Map.prototype.__iterator = function __iterator(type, reverse) {\n    return new MapIterator(this, type, reverse);\n  };\n  Map.prototype.__iterate = function __iterate(fn, reverse) {\n    var this$1$1 = this;\n    var iterations = 0;\n    this._root && this._root.iterate(function (entry) {\n      iterations++;\n      return fn(entry[1], entry[0], this$1$1);\n    }, reverse);\n    return iterations;\n  };\n  Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeMap(this.size, this._root, ownerID, this.__hash);\n  };\n  return Map;\n}(KeyedCollection);\nMap.isMap = isMap;\nvar MapPrototype = Map.prototype;\nMapPrototype[IS_MAP_SYMBOL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeAll = MapPrototype.deleteAll;\nMapPrototype.setIn = setIn;\nMapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\nMapPrototype.update = update;\nMapPrototype.updateIn = updateIn;\nMapPrototype.merge = MapPrototype.concat = merge;\nMapPrototype.mergeWith = mergeWith;\nMapPrototype.mergeDeep = mergeDeep;\nMapPrototype.mergeDeepWith = mergeDeepWith;\nMapPrototype.mergeIn = mergeIn;\nMapPrototype.mergeDeepIn = mergeDeepIn;\nMapPrototype.withMutations = withMutations;\nMapPrototype.wasAltered = wasAltered;\nMapPrototype.asImmutable = asImmutable;\nMapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\nMapPrototype['@@transducer/step'] = function (result, arr) {\n  return result.set(arr[0], arr[1]);\n};\nMapPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\n// #pragma Trie Nodes\n\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n  this.ownerID = ownerID;\n  this.entries = entries;\n};\nArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\nArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n  if (removed && entries.length === 1) {\n    return; // undefined\n  }\n  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n    return createNodes(ownerID, entries, key, value);\n  }\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n  if (exists) {\n    if (removed) {\n      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n  return new ArrayMapNode(ownerID, newEntries);\n};\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n  this.ownerID = ownerID;\n  this.bitmap = bitmap;\n  this.nodes = nodes;\n};\nBitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n  var bitmap = this.bitmap;\n  return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);\n};\nBitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var bit = 1 << keyHashFrag;\n  var bitmap = this.bitmap;\n  var exists = (bitmap & bit) !== 0;\n  if (!exists && value === NOT_SET) {\n    return this;\n  }\n  var idx = popCount(bitmap & bit - 1);\n  var nodes = this.nodes;\n  var node = exists ? nodes[idx] : undefined;\n  var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n  if (newNode === node) {\n    return this;\n  }\n  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n  }\n  if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n    return nodes[idx ^ 1];\n  }\n  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n    return newNode;\n  }\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n  var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);\n  if (isEditable) {\n    this.bitmap = newBitmap;\n    this.nodes = newNodes;\n    return this;\n  }\n  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n  this.ownerID = ownerID;\n  this.count = count;\n  this.nodes = nodes;\n};\nHashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var node = this.nodes[idx];\n  return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n};\nHashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var removed = value === NOT_SET;\n  var nodes = this.nodes;\n  var node = nodes[idx];\n  if (removed && !node) {\n    return this;\n  }\n  var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n  if (newNode === node) {\n    return this;\n  }\n  var newCount = this.count;\n  if (!node) {\n    newCount++;\n  } else if (!newNode) {\n    newCount--;\n    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n      return packNodes(ownerID, nodes, newCount, idx);\n    }\n  }\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newNodes = setAt(nodes, idx, newNode, isEditable);\n  if (isEditable) {\n    this.count = newCount;\n    this.nodes = newNodes;\n    return this;\n  }\n  return new HashArrayMapNode(ownerID, newCount, newNodes);\n};\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entries = entries;\n};\nHashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\nHashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var removed = value === NOT_SET;\n  if (keyHash !== this.keyHash) {\n    if (removed) {\n      return this;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n  }\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n  if (removed && len === 2) {\n    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n  }\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n  if (exists) {\n    if (removed) {\n      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n  return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entry = entry;\n};\nValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\nValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n  var keyMatch = is(key, this.entry[0]);\n  if (keyMatch ? value === this.entry[1] : removed) {\n    return this;\n  }\n  SetRef(didAlter);\n  if (removed) {\n    SetRef(didChangeSize);\n    return; // undefined\n  }\n  if (keyMatch) {\n    if (ownerID && ownerID === this.ownerID) {\n      this.entry[1] = value;\n      return this;\n    }\n    return new ValueNode(ownerID, this.keyHash, [key, value]);\n  }\n  SetRef(didChangeSize);\n  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n};\n\n// #pragma Iterators\n\nArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {\n  var entries = this.entries;\n  for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n      return false;\n    }\n  }\n};\nBitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n  var nodes = this.nodes;\n  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n    var node = nodes[reverse ? maxIndex - ii : ii];\n    if (node && node.iterate(fn, reverse) === false) {\n      return false;\n    }\n  }\n};\n\n// eslint-disable-next-line no-unused-vars\nValueNode.prototype.iterate = function (fn, reverse) {\n  return fn(this.entry);\n};\nvar MapIterator = /*@__PURE__*/function (Iterator) {\n  function MapIterator(map, type, reverse) {\n    this._type = type;\n    this._reverse = reverse;\n    this._stack = map._root && mapIteratorFrame(map._root);\n  }\n  if (Iterator) MapIterator.__proto__ = Iterator;\n  MapIterator.prototype = Object.create(Iterator && Iterator.prototype);\n  MapIterator.prototype.constructor = MapIterator;\n  MapIterator.prototype.next = function next() {\n    var type = this._type;\n    var stack = this._stack;\n    while (stack) {\n      var node = stack.node;\n      var index = stack.index++;\n      var maxIndex = void 0;\n      if (node.entry) {\n        if (index === 0) {\n          return mapIteratorValue(type, node.entry);\n        }\n      } else if (node.entries) {\n        maxIndex = node.entries.length - 1;\n        if (index <= maxIndex) {\n          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n        }\n      } else {\n        maxIndex = node.nodes.length - 1;\n        if (index <= maxIndex) {\n          var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n          if (subNode) {\n            if (subNode.entry) {\n              return mapIteratorValue(type, subNode.entry);\n            }\n            stack = this._stack = mapIteratorFrame(subNode, stack);\n          }\n          continue;\n        }\n      }\n      stack = this._stack = this._stack.__prev;\n    }\n    return iteratorDone();\n  };\n  return MapIterator;\n}(Iterator);\nfunction mapIteratorValue(type, entry) {\n  return iteratorValue(type, entry[0], entry[1]);\n}\nfunction mapIteratorFrame(node, prev) {\n  return {\n    node: node,\n    index: 0,\n    __prev: prev\n  };\n}\nfunction makeMap(size, root, ownerID, hash) {\n  var map = Object.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\nvar EMPTY_MAP;\nfunction emptyMap() {\n  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\nfunction updateMap(map, k, v) {\n  var newRoot;\n  var newSize;\n  if (!map._root) {\n    if (v === NOT_SET) {\n      return map;\n    }\n    newSize = 1;\n    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n  } else {\n    var didChangeSize = MakeRef();\n    var didAlter = MakeRef();\n    newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n    if (!didAlter.value) {\n      return map;\n    }\n    newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n  }\n  if (map.__ownerID) {\n    map.size = newSize;\n    map._root = newRoot;\n    map.__hash = undefined;\n    map.__altered = true;\n    return map;\n  }\n  return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\nfunction updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (!node) {\n    if (value === NOT_SET) {\n      return node;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return new ValueNode(ownerID, keyHash, [key, value]);\n  }\n  return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n}\nfunction isLeafNode(node) {\n  return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n}\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n  if (node.keyHash === keyHash) {\n    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n  }\n  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var newNode;\n  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n}\nfunction createNodes(ownerID, entries, key, value) {\n  if (!ownerID) {\n    ownerID = new OwnerID();\n  }\n  var node = new ValueNode(ownerID, hash(key), [key, value]);\n  for (var ii = 0; ii < entries.length; ii++) {\n    var entry = entries[ii];\n    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n  }\n  return node;\n}\nfunction packNodes(ownerID, nodes, count, excluding) {\n  var bitmap = 0;\n  var packedII = 0;\n  var packedNodes = new Array(count);\n  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n    var node = nodes[ii];\n    if (node !== undefined && ii !== excluding) {\n      bitmap |= bit;\n      packedNodes[packedII++] = node;\n    }\n  }\n  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n  var count = 0;\n  var expandedNodes = new Array(SIZE);\n  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n  }\n  expandedNodes[including] = node;\n  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\nfunction popCount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\nfunction setAt(array, idx, val, canEdit) {\n  var newArray = canEdit ? array : arrCopy(array);\n  newArray[idx] = val;\n  return newArray;\n}\nfunction spliceIn(array, idx, val, canEdit) {\n  var newLen = array.length + 1;\n  if (canEdit && idx + 1 === newLen) {\n    array[idx] = val;\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      newArray[ii] = val;\n      after = -1;\n    } else {\n      newArray[ii] = array[ii + after];\n    }\n  }\n  return newArray;\n}\nfunction spliceOut(array, idx, canEdit) {\n  var newLen = array.length - 1;\n  if (canEdit && idx === newLen) {\n    array.pop();\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      after = 1;\n    }\n    newArray[ii] = array[ii + after];\n  }\n  return newArray;\n}\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\nexport { Map, emptyMap };","map":{"version":3,"names":["is","Collection","KeyedCollection","isMap","IS_MAP_SYMBOL","isOrdered","DELETE","NOT_SET","SetRef","MakeRef","MASK","SHIFT","SIZE","OwnerID","hash","iteratorDone","Iterator","iteratorValue","sortFactory","arrCopy","assertNotInfinite","setIn","deleteIn","update","updateIn","merge","mergeWith","mergeDeep","mergeDeepWith","mergeIn","mergeDeepIn","withMutations","asMutable","asImmutable","wasAltered","OrderedMap","Map","value","undefined","emptyMap","map","iter","size","forEach","v","k","set","__proto__","prototype","Object","create","constructor","of","keyValues","len","arguments","length","i","Error","toString","__toString","get","notSetValue","_root","updateMap","remove","deleteAll","keys","collection","key","clear","__ownerID","__hash","__altered","sort","comparator","sortBy","mapper","context","this$1$1","call","__iterator","type","reverse","MapIterator","__iterate","fn","iterations","iterate","entry","__ensureOwner","ownerID","makeMap","MapPrototype","removeAll","removeIn","concat","result","arr","obj","ArrayMapNode","entries","shift","keyHash","ii","didChangeSize","didAlter","removed","idx","exists","MAX_ARRAY_MAP_SIZE","createNodes","isEditable","newEntries","pop","push","BitmapIndexedNode","bitmap","nodes","bit","popCount","keyHashFrag","node","newNode","updateNode","MAX_BITMAP_INDEXED_SIZE","expandNodes","isLeafNode","newBitmap","newNodes","setAt","spliceOut","spliceIn","HashArrayMapNode","count","newCount","MIN_HASH_ARRAY_MAP_SIZE","packNodes","HashCollisionNode","mergeIntoNode","ValueNode","keyMatch","maxIndex","_type","_reverse","_stack","mapIteratorFrame","next","stack","index","mapIteratorValue","subNode","__prev","prev","root","EMPTY_MAP","newRoot","newSize","idx1","idx2","excluding","packedII","packedNodes","Array","including","expandedNodes","x","array","val","canEdit","newArray","newLen","after"],"sources":["C:/Users/udaym/OneDrive/Desktop/DraftJsEditor/node_modules/immutable/dist/es/Map.js"],"sourcesContent":["/**\n * @license\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport { is } from './is.js';\nimport { Collection, KeyedCollection } from './Collection.js';\nimport { isMap, IS_MAP_SYMBOL } from './predicates/isMap.js';\nimport { isOrdered } from './predicates/isOrdered.js';\nimport { DELETE, NOT_SET, SetRef, MakeRef, MASK, SHIFT, SIZE, OwnerID } from './TrieUtils.js';\nimport { hash } from './Hash.js';\nimport { iteratorDone, Iterator, iteratorValue } from './Iterator.js';\nimport { sortFactory } from './Operations.js';\nimport arrCopy from './utils/arrCopy.js';\nimport assertNotInfinite from './utils/assertNotInfinite.js';\nimport { setIn } from './methods/setIn.js';\nimport { deleteIn } from './methods/deleteIn.js';\nimport { update } from './methods/update.js';\nimport { updateIn } from './methods/updateIn.js';\nimport { merge, mergeWith } from './methods/merge.js';\nimport { mergeDeep, mergeDeepWith } from './methods/mergeDeep.js';\nimport { mergeIn } from './methods/mergeIn.js';\nimport { mergeDeepIn } from './methods/mergeDeepIn.js';\nimport { withMutations } from './methods/withMutations.js';\nimport { asMutable } from './methods/asMutable.js';\nimport { asImmutable } from './methods/asImmutable.js';\nimport { wasAltered } from './methods/wasAltered.js';\nimport { OrderedMap } from './OrderedMap.js';\n\nvar Map = /*@__PURE__*/(function (KeyedCollection) {\n  function Map(value) {\n    return value === undefined || value === null\n      ? emptyMap()\n      : isMap(value) && !isOrdered(value)\n      ? value\n      : emptyMap().withMutations(function (map) {\n          var iter = KeyedCollection(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function (v, k) { return map.set(k, v); });\n        });\n  }\n\n  if ( KeyedCollection ) Map.__proto__ = KeyedCollection;\n  Map.prototype = Object.create( KeyedCollection && KeyedCollection.prototype );\n  Map.prototype.constructor = Map;\n\n  Map.of = function of () {\n    var keyValues = [], len = arguments.length;\n    while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n    return emptyMap().withMutations(function (map) {\n      for (var i = 0; i < keyValues.length; i += 2) {\n        if (i + 1 >= keyValues.length) {\n          throw new Error('Missing value for key: ' + keyValues[i]);\n        }\n        map.set(keyValues[i], keyValues[i + 1]);\n      }\n    });\n  };\n\n  Map.prototype.toString = function toString () {\n    return this.__toString('Map {', '}');\n  };\n\n  // @pragma Access\n\n  Map.prototype.get = function get (k, notSetValue) {\n    return this._root\n      ? this._root.get(0, undefined, k, notSetValue)\n      : notSetValue;\n  };\n\n  // @pragma Modification\n\n  Map.prototype.set = function set (k, v) {\n    return updateMap(this, k, v);\n  };\n\n  Map.prototype.remove = function remove (k) {\n    return updateMap(this, k, NOT_SET);\n  };\n\n  Map.prototype.deleteAll = function deleteAll (keys) {\n    var collection = Collection(keys);\n\n    if (collection.size === 0) {\n      return this;\n    }\n\n    return this.withMutations(function (map) {\n      collection.forEach(function (key) { return map.remove(key); });\n    });\n  };\n\n  Map.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._root = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyMap();\n  };\n\n  // @pragma Composition\n\n  Map.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator));\n  };\n\n  Map.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator, mapper));\n  };\n\n  Map.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    return this.withMutations(function (map) {\n      map.forEach(function (value, key) {\n        map.set(key, mapper.call(context, value, key, this$1$1));\n      });\n    });\n  };\n\n  // @pragma Mutability\n\n  Map.prototype.__iterator = function __iterator (type, reverse) {\n    return new MapIterator(this, type, reverse);\n  };\n\n  Map.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1$1 = this;\n\n    var iterations = 0;\n    this._root &&\n      this._root.iterate(function (entry) {\n        iterations++;\n        return fn(entry[1], entry[0], this$1$1);\n      }, reverse);\n    return iterations;\n  };\n\n  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeMap(this.size, this._root, ownerID, this.__hash);\n  };\n\n  return Map;\n}(KeyedCollection));\n\nMap.isMap = isMap;\n\nvar MapPrototype = Map.prototype;\nMapPrototype[IS_MAP_SYMBOL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeAll = MapPrototype.deleteAll;\nMapPrototype.setIn = setIn;\nMapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\nMapPrototype.update = update;\nMapPrototype.updateIn = updateIn;\nMapPrototype.merge = MapPrototype.concat = merge;\nMapPrototype.mergeWith = mergeWith;\nMapPrototype.mergeDeep = mergeDeep;\nMapPrototype.mergeDeepWith = mergeDeepWith;\nMapPrototype.mergeIn = mergeIn;\nMapPrototype.mergeDeepIn = mergeDeepIn;\nMapPrototype.withMutations = withMutations;\nMapPrototype.wasAltered = wasAltered;\nMapPrototype.asImmutable = asImmutable;\nMapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\nMapPrototype['@@transducer/step'] = function (result, arr) {\n  return result.set(arr[0], arr[1]);\n};\nMapPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\n// #pragma Trie Nodes\n\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n  this.ownerID = ownerID;\n  this.entries = entries;\n};\n\nArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && entries.length === 1) {\n    return; // undefined\n  }\n\n  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n    return createNodes(ownerID, entries, key, value);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new ArrayMapNode(ownerID, newEntries);\n};\n\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n  this.ownerID = ownerID;\n  this.bitmap = bitmap;\n  this.nodes = nodes;\n};\n\nBitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n  var bitmap = this.bitmap;\n  return (bitmap & bit) === 0\n    ? notSetValue\n    : this.nodes[popCount(bitmap & (bit - 1))].get(\n        shift + SHIFT,\n        keyHash,\n        key,\n        notSetValue\n      );\n};\n\nBitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var bit = 1 << keyHashFrag;\n  var bitmap = this.bitmap;\n  var exists = (bitmap & bit) !== 0;\n\n  if (!exists && value === NOT_SET) {\n    return this;\n  }\n\n  var idx = popCount(bitmap & (bit - 1));\n  var nodes = this.nodes;\n  var node = exists ? nodes[idx] : undefined;\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n\n  if (newNode === node) {\n    return this;\n  }\n\n  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n  }\n\n  if (\n    exists &&\n    !newNode &&\n    nodes.length === 2 &&\n    isLeafNode(nodes[idx ^ 1])\n  ) {\n    return nodes[idx ^ 1];\n  }\n\n  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n    return newNode;\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;\n  var newNodes = exists\n    ? newNode\n      ? setAt(nodes, idx, newNode, isEditable)\n      : spliceOut(nodes, idx, isEditable)\n    : spliceIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.bitmap = newBitmap;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\n\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n  this.ownerID = ownerID;\n  this.count = count;\n  this.nodes = nodes;\n};\n\nHashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var node = this.nodes[idx];\n  return node\n    ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n    : notSetValue;\n};\n\nHashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var removed = value === NOT_SET;\n  var nodes = this.nodes;\n  var node = nodes[idx];\n\n  if (removed && !node) {\n    return this;\n  }\n\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n  if (newNode === node) {\n    return this;\n  }\n\n  var newCount = this.count;\n  if (!node) {\n    newCount++;\n  } else if (!newNode) {\n    newCount--;\n    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n      return packNodes(ownerID, nodes, newCount, idx);\n    }\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newNodes = setAt(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.count = newCount;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new HashArrayMapNode(ownerID, newCount, newNodes);\n};\n\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entries = entries;\n};\n\nHashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nHashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n\n  var removed = value === NOT_SET;\n\n  if (keyHash !== this.keyHash) {\n    if (removed) {\n      return this;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n  }\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && len === 2) {\n    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\n\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entry = entry;\n};\n\nValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\n\nValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n  var keyMatch = is(key, this.entry[0]);\n  if (keyMatch ? value === this.entry[1] : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n\n  if (removed) {\n    SetRef(didChangeSize);\n    return; // undefined\n  }\n\n  if (keyMatch) {\n    if (ownerID && ownerID === this.ownerID) {\n      this.entry[1] = value;\n      return this;\n    }\n    return new ValueNode(ownerID, this.keyHash, [key, value]);\n  }\n\n  SetRef(didChangeSize);\n  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n};\n\n// #pragma Iterators\n\nArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate =\n  function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  };\n\nBitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate =\n  function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  };\n\n// eslint-disable-next-line no-unused-vars\nValueNode.prototype.iterate = function (fn, reverse) {\n  return fn(this.entry);\n};\n\nvar MapIterator = /*@__PURE__*/(function (Iterator) {\n  function MapIterator(map, type, reverse) {\n    this._type = type;\n    this._reverse = reverse;\n    this._stack = map._root && mapIteratorFrame(map._root);\n  }\n\n  if ( Iterator ) MapIterator.__proto__ = Iterator;\n  MapIterator.prototype = Object.create( Iterator && Iterator.prototype );\n  MapIterator.prototype.constructor = MapIterator;\n\n  MapIterator.prototype.next = function next () {\n    var type = this._type;\n    var stack = this._stack;\n    while (stack) {\n      var node = stack.node;\n      var index = stack.index++;\n      var maxIndex = (void 0);\n      if (node.entry) {\n        if (index === 0) {\n          return mapIteratorValue(type, node.entry);\n        }\n      } else if (node.entries) {\n        maxIndex = node.entries.length - 1;\n        if (index <= maxIndex) {\n          return mapIteratorValue(\n            type,\n            node.entries[this._reverse ? maxIndex - index : index]\n          );\n        }\n      } else {\n        maxIndex = node.nodes.length - 1;\n        if (index <= maxIndex) {\n          var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n          if (subNode) {\n            if (subNode.entry) {\n              return mapIteratorValue(type, subNode.entry);\n            }\n            stack = this._stack = mapIteratorFrame(subNode, stack);\n          }\n          continue;\n        }\n      }\n      stack = this._stack = this._stack.__prev;\n    }\n    return iteratorDone();\n  };\n\n  return MapIterator;\n}(Iterator));\n\nfunction mapIteratorValue(type, entry) {\n  return iteratorValue(type, entry[0], entry[1]);\n}\n\nfunction mapIteratorFrame(node, prev) {\n  return {\n    node: node,\n    index: 0,\n    __prev: prev,\n  };\n}\n\nfunction makeMap(size, root, ownerID, hash) {\n  var map = Object.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_MAP;\nfunction emptyMap() {\n  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\n\nfunction updateMap(map, k, v) {\n  var newRoot;\n  var newSize;\n  if (!map._root) {\n    if (v === NOT_SET) {\n      return map;\n    }\n    newSize = 1;\n    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n  } else {\n    var didChangeSize = MakeRef();\n    var didAlter = MakeRef();\n    newRoot = updateNode(\n      map._root,\n      map.__ownerID,\n      0,\n      undefined,\n      k,\n      v,\n      didChangeSize,\n      didAlter\n    );\n    if (!didAlter.value) {\n      return map;\n    }\n    newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);\n  }\n  if (map.__ownerID) {\n    map.size = newSize;\n    map._root = newRoot;\n    map.__hash = undefined;\n    map.__altered = true;\n    return map;\n  }\n  return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\n\nfunction updateNode(\n  node,\n  ownerID,\n  shift,\n  keyHash,\n  key,\n  value,\n  didChangeSize,\n  didAlter\n) {\n  if (!node) {\n    if (value === NOT_SET) {\n      return node;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return new ValueNode(ownerID, keyHash, [key, value]);\n  }\n  return node.update(\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n}\n\nfunction isLeafNode(node) {\n  return (\n    node.constructor === ValueNode || node.constructor === HashCollisionNode\n  );\n}\n\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n  if (node.keyHash === keyHash) {\n    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n  }\n\n  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n  var newNode;\n  var nodes =\n    idx1 === idx2\n      ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n      : ((newNode = new ValueNode(ownerID, keyHash, entry)),\n        idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n  return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n}\n\nfunction createNodes(ownerID, entries, key, value) {\n  if (!ownerID) {\n    ownerID = new OwnerID();\n  }\n  var node = new ValueNode(ownerID, hash(key), [key, value]);\n  for (var ii = 0; ii < entries.length; ii++) {\n    var entry = entries[ii];\n    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n  }\n  return node;\n}\n\nfunction packNodes(ownerID, nodes, count, excluding) {\n  var bitmap = 0;\n  var packedII = 0;\n  var packedNodes = new Array(count);\n  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n    var node = nodes[ii];\n    if (node !== undefined && ii !== excluding) {\n      bitmap |= bit;\n      packedNodes[packedII++] = node;\n    }\n  }\n  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\n\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n  var count = 0;\n  var expandedNodes = new Array(SIZE);\n  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n  }\n  expandedNodes[including] = node;\n  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\n\nfunction popCount(x) {\n  x -= (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n\nfunction setAt(array, idx, val, canEdit) {\n  var newArray = canEdit ? array : arrCopy(array);\n  newArray[idx] = val;\n  return newArray;\n}\n\nfunction spliceIn(array, idx, val, canEdit) {\n  var newLen = array.length + 1;\n  if (canEdit && idx + 1 === newLen) {\n    array[idx] = val;\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      newArray[ii] = val;\n      after = -1;\n    } else {\n      newArray[ii] = array[ii + after];\n    }\n  }\n  return newArray;\n}\n\nfunction spliceOut(array, idx, canEdit) {\n  var newLen = array.length - 1;\n  if (canEdit && idx === newLen) {\n    array.pop();\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      after = 1;\n    }\n    newArray[ii] = array[ii + after];\n  }\n  return newArray;\n}\n\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\nexport { Map, emptyMap };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}