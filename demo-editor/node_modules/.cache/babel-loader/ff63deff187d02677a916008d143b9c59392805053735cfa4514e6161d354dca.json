{"ast":null,"code":"/**\n * @license\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport { wrapIndex, MASK, SHIFT, wholeSlice, DELETE, SetRef, OwnerID, SIZE, MakeRef, resolveEnd, resolveBegin } from './TrieUtils.js';\nimport { isList, IS_LIST_SYMBOL } from './predicates/isList.js';\nimport { IndexedCollection } from './Collection.js';\nimport { hasIterator, Iterator, iteratorDone, iteratorValue } from './Iterator.js';\nimport { setIn } from './methods/setIn.js';\nimport { deleteIn } from './methods/deleteIn.js';\nimport { update } from './methods/update.js';\nimport { updateIn } from './methods/updateIn.js';\nimport { mergeIn } from './methods/mergeIn.js';\nimport { mergeDeepIn } from './methods/mergeDeepIn.js';\nimport { withMutations } from './methods/withMutations.js';\nimport { asMutable } from './methods/asMutable.js';\nimport { asImmutable } from './methods/asImmutable.js';\nimport { wasAltered } from './methods/wasAltered.js';\nimport assertNotInfinite from './utils/assertNotInfinite.js';\nvar List = /*@__PURE__*/function (IndexedCollection) {\n  function List(value) {\n    var empty = emptyList();\n    if (value === undefined || value === null) {\n      return empty;\n    }\n    if (isList(value)) {\n      return value;\n    }\n    var iter = IndexedCollection(value);\n    var size = iter.size;\n    if (size === 0) {\n      return empty;\n    }\n    assertNotInfinite(size);\n    if (size > 0 && size < SIZE) {\n      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n    }\n    return empty.withMutations(function (list) {\n      list.setSize(size);\n      iter.forEach(function (v, i) {\n        return list.set(i, v);\n      });\n    });\n  }\n  if (IndexedCollection) List.__proto__ = IndexedCollection;\n  List.prototype = Object.create(IndexedCollection && IndexedCollection.prototype);\n  List.prototype.constructor = List;\n  List.of = function of( /*...values*/\n  ) {\n    return this(arguments);\n  };\n  List.prototype.toString = function toString() {\n    return this.__toString('List [', ']');\n  };\n\n  // @pragma Access\n\n  List.prototype.get = function get(index, notSetValue) {\n    index = wrapIndex(this, index);\n    if (index >= 0 && index < this.size) {\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    }\n    return notSetValue;\n  };\n\n  // @pragma Modification\n\n  List.prototype.set = function set(index, value) {\n    return updateList(this, index, value);\n  };\n  List.prototype.remove = function remove(index) {\n    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n  };\n  List.prototype.insert = function insert(index, value) {\n    return this.splice(index, 0, value);\n  };\n  List.prototype.clear = function clear() {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = this._origin = this._capacity = 0;\n      this._level = SHIFT;\n      this._root = this._tail = this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyList();\n  };\n  List.prototype.push = function push( /*...values*/\n  ) {\n    var values = arguments;\n    var oldSize = this.size;\n    return this.withMutations(function (list) {\n      setListBounds(list, 0, oldSize + values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(oldSize + ii, values[ii]);\n      }\n    });\n  };\n  List.prototype.pop = function pop() {\n    return setListBounds(this, 0, -1);\n  };\n  List.prototype.unshift = function unshift( /*...values*/\n  ) {\n    var values = arguments;\n    return this.withMutations(function (list) {\n      setListBounds(list, -values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(ii, values[ii]);\n      }\n    });\n  };\n  List.prototype.shift = function shift() {\n    return setListBounds(this, 1);\n  };\n\n  // @pragma Composition\n\n  List.prototype.concat = function concat( /*...collections*/\n  ) {\n    var arguments$1 = arguments;\n    var seqs = [];\n    for (var i = 0; i < arguments.length; i++) {\n      var argument = arguments$1[i];\n      var seq = IndexedCollection(typeof argument !== 'string' && hasIterator(argument) ? argument : [argument]);\n      if (seq.size !== 0) {\n        seqs.push(seq);\n      }\n    }\n    if (seqs.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n      return this.constructor(seqs[0]);\n    }\n    return this.withMutations(function (list) {\n      seqs.forEach(function (seq) {\n        return seq.forEach(function (value) {\n          return list.push(value);\n        });\n      });\n    });\n  };\n  List.prototype.setSize = function setSize(size) {\n    return setListBounds(this, 0, size);\n  };\n  List.prototype.map = function map(mapper, context) {\n    var this$1$1 = this;\n    return this.withMutations(function (list) {\n      for (var i = 0; i < this$1$1.size; i++) {\n        list.set(i, mapper.call(context, list.get(i), i, this$1$1));\n      }\n    });\n  };\n\n  // @pragma Iteration\n\n  List.prototype.slice = function slice(begin, end) {\n    var size = this.size;\n    if (wholeSlice(begin, end, size)) {\n      return this;\n    }\n    return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));\n  };\n  List.prototype.__iterator = function __iterator(type, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    return new Iterator(function () {\n      var value = values();\n      return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);\n    });\n  };\n  List.prototype.__iterate = function __iterate(fn, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    var value;\n    while ((value = values()) !== DONE) {\n      if (fn(value, reverse ? --index : index++, this) === false) {\n        break;\n      }\n    }\n    return index;\n  };\n  List.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyList();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n  };\n  return List;\n}(IndexedCollection);\nList.isList = isList;\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SYMBOL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.merge = ListPrototype.concat;\nListPrototype.setIn = setIn;\nListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\nListPrototype.update = update;\nListPrototype.updateIn = updateIn;\nListPrototype.mergeIn = mergeIn;\nListPrototype.mergeDeepIn = mergeDeepIn;\nListPrototype.withMutations = withMutations;\nListPrototype.wasAltered = wasAltered;\nListPrototype.asImmutable = asImmutable;\nListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\nListPrototype['@@transducer/step'] = function (result, arr) {\n  return result.push(arr);\n};\nListPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\nvar VNode = function VNode(array, ownerID) {\n  this.array = array;\n  this.ownerID = ownerID;\n};\n\n// TODO: seems like these methods are very similar\n\nVNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {\n  if (index === level ? 1 << level : this.array.length === 0) {\n    return this;\n  }\n  var originIndex = index >>> level & MASK;\n  if (originIndex >= this.array.length) {\n    return new VNode([], ownerID);\n  }\n  var removingFirst = originIndex === 0;\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[originIndex];\n    newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && removingFirst) {\n      return this;\n    }\n  }\n  if (removingFirst && !newChild) {\n    return this;\n  }\n  var editable = editableVNode(this, ownerID);\n  if (!removingFirst) {\n    for (var ii = 0; ii < originIndex; ii++) {\n      editable.array[ii] = undefined;\n    }\n  }\n  if (newChild) {\n    editable.array[originIndex] = newChild;\n  }\n  return editable;\n};\nVNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {\n  if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n    return this;\n  }\n  var sizeIndex = index - 1 >>> level & MASK;\n  if (sizeIndex >= this.array.length) {\n    return this;\n  }\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[sizeIndex];\n    newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n      return this;\n    }\n  }\n  var editable = editableVNode(this, ownerID);\n  editable.array.splice(sizeIndex + 1);\n  if (newChild) {\n    editable.array[sizeIndex] = newChild;\n  }\n  return editable;\n};\nvar DONE = {};\nfunction iterateList(list, reverse) {\n  var left = list._origin;\n  var right = list._capacity;\n  var tailPos = getTailOffset(right);\n  var tail = list._tail;\n  return iterateNodeOrLeaf(list._root, list._level, 0);\n  function iterateNodeOrLeaf(node, level, offset) {\n    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);\n  }\n  function iterateLeaf(node, offset) {\n    var array = offset === tailPos ? tail && tail.array : node && node.array;\n    var from = offset > left ? 0 : left - offset;\n    var to = right - offset;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      if (from === to) {\n        return DONE;\n      }\n      var idx = reverse ? --to : from++;\n      return array && array[idx];\n    };\n  }\n  function iterateNode(node, level, offset) {\n    var values;\n    var array = node && node.array;\n    var from = offset > left ? 0 : left - offset >> level;\n    var to = (right - offset >> level) + 1;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      while (true) {\n        if (values) {\n          var value = values();\n          if (value !== DONE) {\n            return value;\n          }\n          values = null;\n        }\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));\n      }\n    };\n  }\n}\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n  var list = Object.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = false;\n  return list;\n}\nvar EMPTY_LIST;\nfunction emptyList() {\n  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\nfunction updateList(list, index, value) {\n  index = wrapIndex(list, index);\n  if (index !== index) {\n    return list;\n  }\n  if (index >= list.size || index < 0) {\n    return list.withMutations(function (list) {\n      index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);\n    });\n  }\n  index += list._origin;\n  var newTail = list._tail;\n  var newRoot = list._root;\n  var didAlter = MakeRef();\n  if (index >= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n  } else {\n    newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n  }\n  if (!didAlter.value) {\n    return list;\n  }\n  if (list.__ownerID) {\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n  var idx = index >>> level & MASK;\n  var nodeHas = node && idx < node.array.length;\n  if (!nodeHas && value === undefined) {\n    return node;\n  }\n  var newNode;\n  if (level > 0) {\n    var lowerNode = node && node.array[idx];\n    var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n    if (newLowerNode === lowerNode) {\n      return node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    return newNode;\n  }\n  if (nodeHas && node.array[idx] === value) {\n    return node;\n  }\n  if (didAlter) {\n    SetRef(didAlter);\n  }\n  newNode = editableVNode(node, ownerID);\n  if (value === undefined && idx === newNode.array.length - 1) {\n    newNode.array.pop();\n  } else {\n    newNode.array[idx] = value;\n  }\n  return newNode;\n}\nfunction editableVNode(node, ownerID) {\n  if (ownerID && node && ownerID === node.ownerID) {\n    return node;\n  }\n  return new VNode(node ? node.array.slice() : [], ownerID);\n}\nfunction listNodeFor(list, rawIndex) {\n  if (rawIndex >= getTailOffset(list._capacity)) {\n    return list._tail;\n  }\n  if (rawIndex < 1 << list._level + SHIFT) {\n    var node = list._root;\n    var level = list._level;\n    while (node && level > 0) {\n      node = node.array[rawIndex >>> level & MASK];\n      level -= SHIFT;\n    }\n    return node;\n  }\n}\nfunction setListBounds(list, begin, end) {\n  // Sanitize begin & end using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  if (begin !== undefined) {\n    begin |= 0;\n  }\n  if (end !== undefined) {\n    end |= 0;\n  }\n  var owner = list.__ownerID || new OwnerID();\n  var oldOrigin = list._origin;\n  var oldCapacity = list._capacity;\n  var newOrigin = oldOrigin + begin;\n  var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n    return list;\n  }\n\n  // If it's going to end after it starts, it's empty.\n  if (newOrigin >= newCapacity) {\n    return list.clear();\n  }\n  var newLevel = list._level;\n  var newRoot = list._root;\n\n  // New origin might need creating a higher root.\n  var offsetShift = 0;\n  while (newOrigin + offsetShift < 0) {\n    newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n    newLevel += SHIFT;\n    offsetShift += 1 << newLevel;\n  }\n  if (offsetShift) {\n    newOrigin += offsetShift;\n    oldOrigin += offsetShift;\n    newCapacity += offsetShift;\n    oldCapacity += offsetShift;\n  }\n  var oldTailOffset = getTailOffset(oldCapacity);\n  var newTailOffset = getTailOffset(newCapacity);\n\n  // New size might need creating a higher root.\n  while (newTailOffset >= 1 << newLevel + SHIFT) {\n    newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n    newLevel += SHIFT;\n  }\n\n  // Locate or create the new tail.\n  var oldTail = list._tail;\n  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n  // Merge Tail into tree.\n  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n    newRoot = editableVNode(newRoot, owner);\n    var node = newRoot;\n    for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n      var idx = oldTailOffset >>> level & MASK;\n      node = node.array[idx] = editableVNode(node.array[idx], owner);\n    }\n    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n  }\n\n  // If the size has been reduced, there's a chance the tail needs to be trimmed.\n  if (newCapacity < oldCapacity) {\n    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n  }\n\n  // If the new origin is within the tail, then we do not need a root.\n  if (newOrigin >= newTailOffset) {\n    newOrigin -= newTailOffset;\n    newCapacity -= newTailOffset;\n    newLevel = SHIFT;\n    newRoot = null;\n    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n    offsetShift = 0;\n\n    // Identify the new top root node of the subtree of the old root.\n    while (newRoot) {\n      var beginIndex = newOrigin >>> newLevel & MASK;\n      if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n        break;\n      }\n      if (beginIndex) {\n        offsetShift += (1 << newLevel) * beginIndex;\n      }\n      newLevel -= SHIFT;\n      newRoot = newRoot.array[beginIndex];\n    }\n\n    // Trim the new sides of the new root.\n    if (newRoot && newOrigin > oldOrigin) {\n      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n    }\n    if (newRoot && newTailOffset < oldTailOffset) {\n      newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n    }\n    if (offsetShift) {\n      newOrigin -= offsetShift;\n      newCapacity -= offsetShift;\n    }\n  }\n  if (list.__ownerID) {\n    list.size = newCapacity - newOrigin;\n    list._origin = newOrigin;\n    list._capacity = newCapacity;\n    list._level = newLevel;\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\nfunction getTailOffset(size) {\n  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n}\nexport { List, emptyList };","map":{"version":3,"names":["wrapIndex","MASK","SHIFT","wholeSlice","DELETE","SetRef","OwnerID","SIZE","MakeRef","resolveEnd","resolveBegin","isList","IS_LIST_SYMBOL","IndexedCollection","hasIterator","Iterator","iteratorDone","iteratorValue","setIn","deleteIn","update","updateIn","mergeIn","mergeDeepIn","withMutations","asMutable","asImmutable","wasAltered","assertNotInfinite","List","value","empty","emptyList","undefined","iter","size","makeList","VNode","toArray","list","setSize","forEach","v","i","set","__proto__","prototype","Object","create","constructor","of","arguments","toString","__toString","get","index","notSetValue","_origin","node","listNodeFor","array","updateList","remove","has","shift","pop","splice","insert","clear","__ownerID","_capacity","_level","_root","_tail","__hash","__altered","push","values","oldSize","setListBounds","length","ii","unshift","concat","arguments$1","seqs","argument","seq","map","mapper","context","this$1$1","call","slice","begin","end","__iterator","type","reverse","iterateList","DONE","__iterate","fn","__ensureOwner","ownerID","ListPrototype","merge","removeIn","result","arr","obj","removeBefore","level","originIndex","removingFirst","newChild","oldChild","editable","editableVNode","removeAfter","sizeIndex","left","right","tailPos","getTailOffset","tail","iterateNodeOrLeaf","offset","iterateLeaf","iterateNode","from","to","idx","origin","capacity","root","hash","EMPTY_LIST","newTail","newRoot","didAlter","updateVNode","nodeHas","newNode","lowerNode","newLowerNode","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","beginIndex"],"sources":["C:/Users/udaym/OneDrive/Desktop/DraftJsEditor/node_modules/immutable/dist/es/List.js"],"sourcesContent":["/**\n * @license\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport { wrapIndex, MASK, SHIFT, wholeSlice, DELETE, SetRef, OwnerID, SIZE, MakeRef, resolveEnd, resolveBegin } from './TrieUtils.js';\nimport { isList, IS_LIST_SYMBOL } from './predicates/isList.js';\nimport { IndexedCollection } from './Collection.js';\nimport { hasIterator, Iterator, iteratorDone, iteratorValue } from './Iterator.js';\nimport { setIn } from './methods/setIn.js';\nimport { deleteIn } from './methods/deleteIn.js';\nimport { update } from './methods/update.js';\nimport { updateIn } from './methods/updateIn.js';\nimport { mergeIn } from './methods/mergeIn.js';\nimport { mergeDeepIn } from './methods/mergeDeepIn.js';\nimport { withMutations } from './methods/withMutations.js';\nimport { asMutable } from './methods/asMutable.js';\nimport { asImmutable } from './methods/asImmutable.js';\nimport { wasAltered } from './methods/wasAltered.js';\nimport assertNotInfinite from './utils/assertNotInfinite.js';\n\nvar List = /*@__PURE__*/(function (IndexedCollection) {\n  function List(value) {\n    var empty = emptyList();\n    if (value === undefined || value === null) {\n      return empty;\n    }\n    if (isList(value)) {\n      return value;\n    }\n    var iter = IndexedCollection(value);\n    var size = iter.size;\n    if (size === 0) {\n      return empty;\n    }\n    assertNotInfinite(size);\n    if (size > 0 && size < SIZE) {\n      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n    }\n    return empty.withMutations(function (list) {\n      list.setSize(size);\n      iter.forEach(function (v, i) { return list.set(i, v); });\n    });\n  }\n\n  if ( IndexedCollection ) List.__proto__ = IndexedCollection;\n  List.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n  List.prototype.constructor = List;\n\n  List.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  List.prototype.toString = function toString () {\n    return this.__toString('List [', ']');\n  };\n\n  // @pragma Access\n\n  List.prototype.get = function get (index, notSetValue) {\n    index = wrapIndex(this, index);\n    if (index >= 0 && index < this.size) {\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    }\n    return notSetValue;\n  };\n\n  // @pragma Modification\n\n  List.prototype.set = function set (index, value) {\n    return updateList(this, index, value);\n  };\n\n  List.prototype.remove = function remove (index) {\n    return !this.has(index)\n      ? this\n      : index === 0\n      ? this.shift()\n      : index === this.size - 1\n      ? this.pop()\n      : this.splice(index, 1);\n  };\n\n  List.prototype.insert = function insert (index, value) {\n    return this.splice(index, 0, value);\n  };\n\n  List.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = this._origin = this._capacity = 0;\n      this._level = SHIFT;\n      this._root = this._tail = this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyList();\n  };\n\n  List.prototype.push = function push (/*...values*/) {\n    var values = arguments;\n    var oldSize = this.size;\n    return this.withMutations(function (list) {\n      setListBounds(list, 0, oldSize + values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(oldSize + ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.pop = function pop () {\n    return setListBounds(this, 0, -1);\n  };\n\n  List.prototype.unshift = function unshift (/*...values*/) {\n    var values = arguments;\n    return this.withMutations(function (list) {\n      setListBounds(list, -values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.shift = function shift () {\n    return setListBounds(this, 1);\n  };\n\n  // @pragma Composition\n\n  List.prototype.concat = function concat (/*...collections*/) {\n    var arguments$1 = arguments;\n\n    var seqs = [];\n    for (var i = 0; i < arguments.length; i++) {\n      var argument = arguments$1[i];\n      var seq = IndexedCollection(\n        typeof argument !== 'string' && hasIterator(argument)\n          ? argument\n          : [argument]\n      );\n      if (seq.size !== 0) {\n        seqs.push(seq);\n      }\n    }\n    if (seqs.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n      return this.constructor(seqs[0]);\n    }\n    return this.withMutations(function (list) {\n      seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });\n    });\n  };\n\n  List.prototype.setSize = function setSize (size) {\n    return setListBounds(this, 0, size);\n  };\n\n  List.prototype.map = function map (mapper, context) {\n    var this$1$1 = this;\n\n    return this.withMutations(function (list) {\n      for (var i = 0; i < this$1$1.size; i++) {\n        list.set(i, mapper.call(context, list.get(i), i, this$1$1));\n      }\n    });\n  };\n\n  // @pragma Iteration\n\n  List.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    if (wholeSlice(begin, end, size)) {\n      return this;\n    }\n    return setListBounds(\n      this,\n      resolveBegin(begin, size),\n      resolveEnd(end, size)\n    );\n  };\n\n  List.prototype.__iterator = function __iterator (type, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    return new Iterator(function () {\n      var value = values();\n      return value === DONE\n        ? iteratorDone()\n        : iteratorValue(type, reverse ? --index : index++, value);\n    });\n  };\n\n  List.prototype.__iterate = function __iterate (fn, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    var value;\n    while ((value = values()) !== DONE) {\n      if (fn(value, reverse ? --index : index++, this) === false) {\n        break;\n      }\n    }\n    return index;\n  };\n\n  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyList();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeList(\n      this._origin,\n      this._capacity,\n      this._level,\n      this._root,\n      this._tail,\n      ownerID,\n      this.__hash\n    );\n  };\n\n  return List;\n}(IndexedCollection));\n\nList.isList = isList;\n\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SYMBOL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.merge = ListPrototype.concat;\nListPrototype.setIn = setIn;\nListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\nListPrototype.update = update;\nListPrototype.updateIn = updateIn;\nListPrototype.mergeIn = mergeIn;\nListPrototype.mergeDeepIn = mergeDeepIn;\nListPrototype.withMutations = withMutations;\nListPrototype.wasAltered = wasAltered;\nListPrototype.asImmutable = asImmutable;\nListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\nListPrototype['@@transducer/step'] = function (result, arr) {\n  return result.push(arr);\n};\nListPrototype['@@transducer/result'] = function (obj) {\n  return obj.asImmutable();\n};\n\nvar VNode = function VNode(array, ownerID) {\n  this.array = array;\n  this.ownerID = ownerID;\n};\n\n// TODO: seems like these methods are very similar\n\nVNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n  if (index === level ? 1 << level : this.array.length === 0) {\n    return this;\n  }\n  var originIndex = (index >>> level) & MASK;\n  if (originIndex >= this.array.length) {\n    return new VNode([], ownerID);\n  }\n  var removingFirst = originIndex === 0;\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[originIndex];\n    newChild =\n      oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && removingFirst) {\n      return this;\n    }\n  }\n  if (removingFirst && !newChild) {\n    return this;\n  }\n  var editable = editableVNode(this, ownerID);\n  if (!removingFirst) {\n    for (var ii = 0; ii < originIndex; ii++) {\n      editable.array[ii] = undefined;\n    }\n  }\n  if (newChild) {\n    editable.array[originIndex] = newChild;\n  }\n  return editable;\n};\n\nVNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n  if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n    return this;\n  }\n  var sizeIndex = ((index - 1) >>> level) & MASK;\n  if (sizeIndex >= this.array.length) {\n    return this;\n  }\n\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[sizeIndex];\n    newChild =\n      oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n      return this;\n    }\n  }\n\n  var editable = editableVNode(this, ownerID);\n  editable.array.splice(sizeIndex + 1);\n  if (newChild) {\n    editable.array[sizeIndex] = newChild;\n  }\n  return editable;\n};\n\nvar DONE = {};\n\nfunction iterateList(list, reverse) {\n  var left = list._origin;\n  var right = list._capacity;\n  var tailPos = getTailOffset(right);\n  var tail = list._tail;\n\n  return iterateNodeOrLeaf(list._root, list._level, 0);\n\n  function iterateNodeOrLeaf(node, level, offset) {\n    return level === 0\n      ? iterateLeaf(node, offset)\n      : iterateNode(node, level, offset);\n  }\n\n  function iterateLeaf(node, offset) {\n    var array = offset === tailPos ? tail && tail.array : node && node.array;\n    var from = offset > left ? 0 : left - offset;\n    var to = right - offset;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      if (from === to) {\n        return DONE;\n      }\n      var idx = reverse ? --to : from++;\n      return array && array[idx];\n    };\n  }\n\n  function iterateNode(node, level, offset) {\n    var values;\n    var array = node && node.array;\n    var from = offset > left ? 0 : (left - offset) >> level;\n    var to = ((right - offset) >> level) + 1;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      while (true) {\n        if (values) {\n          var value = values();\n          if (value !== DONE) {\n            return value;\n          }\n          values = null;\n        }\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        values = iterateNodeOrLeaf(\n          array && array[idx],\n          level - SHIFT,\n          offset + (idx << level)\n        );\n      }\n    };\n  }\n}\n\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n  var list = Object.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = false;\n  return list;\n}\n\nvar EMPTY_LIST;\nfunction emptyList() {\n  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\n\nfunction updateList(list, index, value) {\n  index = wrapIndex(list, index);\n\n  if (index !== index) {\n    return list;\n  }\n\n  if (index >= list.size || index < 0) {\n    return list.withMutations(function (list) {\n      index < 0\n        ? setListBounds(list, index).set(0, value)\n        : setListBounds(list, 0, index + 1).set(index, value);\n    });\n  }\n\n  index += list._origin;\n\n  var newTail = list._tail;\n  var newRoot = list._root;\n  var didAlter = MakeRef();\n  if (index >= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n  } else {\n    newRoot = updateVNode(\n      newRoot,\n      list.__ownerID,\n      list._level,\n      index,\n      value,\n      didAlter\n    );\n  }\n\n  if (!didAlter.value) {\n    return list;\n  }\n\n  if (list.__ownerID) {\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\n\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n  var idx = (index >>> level) & MASK;\n  var nodeHas = node && idx < node.array.length;\n  if (!nodeHas && value === undefined) {\n    return node;\n  }\n\n  var newNode;\n\n  if (level > 0) {\n    var lowerNode = node && node.array[idx];\n    var newLowerNode = updateVNode(\n      lowerNode,\n      ownerID,\n      level - SHIFT,\n      index,\n      value,\n      didAlter\n    );\n    if (newLowerNode === lowerNode) {\n      return node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    return newNode;\n  }\n\n  if (nodeHas && node.array[idx] === value) {\n    return node;\n  }\n\n  if (didAlter) {\n    SetRef(didAlter);\n  }\n\n  newNode = editableVNode(node, ownerID);\n  if (value === undefined && idx === newNode.array.length - 1) {\n    newNode.array.pop();\n  } else {\n    newNode.array[idx] = value;\n  }\n  return newNode;\n}\n\nfunction editableVNode(node, ownerID) {\n  if (ownerID && node && ownerID === node.ownerID) {\n    return node;\n  }\n  return new VNode(node ? node.array.slice() : [], ownerID);\n}\n\nfunction listNodeFor(list, rawIndex) {\n  if (rawIndex >= getTailOffset(list._capacity)) {\n    return list._tail;\n  }\n  if (rawIndex < 1 << (list._level + SHIFT)) {\n    var node = list._root;\n    var level = list._level;\n    while (node && level > 0) {\n      node = node.array[(rawIndex >>> level) & MASK];\n      level -= SHIFT;\n    }\n    return node;\n  }\n}\n\nfunction setListBounds(list, begin, end) {\n  // Sanitize begin & end using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  if (begin !== undefined) {\n    begin |= 0;\n  }\n  if (end !== undefined) {\n    end |= 0;\n  }\n  var owner = list.__ownerID || new OwnerID();\n  var oldOrigin = list._origin;\n  var oldCapacity = list._capacity;\n  var newOrigin = oldOrigin + begin;\n  var newCapacity =\n    end === undefined\n      ? oldCapacity\n      : end < 0\n      ? oldCapacity + end\n      : oldOrigin + end;\n  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n    return list;\n  }\n\n  // If it's going to end after it starts, it's empty.\n  if (newOrigin >= newCapacity) {\n    return list.clear();\n  }\n\n  var newLevel = list._level;\n  var newRoot = list._root;\n\n  // New origin might need creating a higher root.\n  var offsetShift = 0;\n  while (newOrigin + offsetShift < 0) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n    offsetShift += 1 << newLevel;\n  }\n  if (offsetShift) {\n    newOrigin += offsetShift;\n    oldOrigin += offsetShift;\n    newCapacity += offsetShift;\n    oldCapacity += offsetShift;\n  }\n\n  var oldTailOffset = getTailOffset(oldCapacity);\n  var newTailOffset = getTailOffset(newCapacity);\n\n  // New size might need creating a higher root.\n  while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n  }\n\n  // Locate or create the new tail.\n  var oldTail = list._tail;\n  var newTail =\n    newTailOffset < oldTailOffset\n      ? listNodeFor(list, newCapacity - 1)\n      : newTailOffset > oldTailOffset\n      ? new VNode([], owner)\n      : oldTail;\n\n  // Merge Tail into tree.\n  if (\n    oldTail &&\n    newTailOffset > oldTailOffset &&\n    newOrigin < oldCapacity &&\n    oldTail.array.length\n  ) {\n    newRoot = editableVNode(newRoot, owner);\n    var node = newRoot;\n    for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n      var idx = (oldTailOffset >>> level) & MASK;\n      node = node.array[idx] = editableVNode(node.array[idx], owner);\n    }\n    node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n  }\n\n  // If the size has been reduced, there's a chance the tail needs to be trimmed.\n  if (newCapacity < oldCapacity) {\n    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n  }\n\n  // If the new origin is within the tail, then we do not need a root.\n  if (newOrigin >= newTailOffset) {\n    newOrigin -= newTailOffset;\n    newCapacity -= newTailOffset;\n    newLevel = SHIFT;\n    newRoot = null;\n    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n    offsetShift = 0;\n\n    // Identify the new top root node of the subtree of the old root.\n    while (newRoot) {\n      var beginIndex = (newOrigin >>> newLevel) & MASK;\n      if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {\n        break;\n      }\n      if (beginIndex) {\n        offsetShift += (1 << newLevel) * beginIndex;\n      }\n      newLevel -= SHIFT;\n      newRoot = newRoot.array[beginIndex];\n    }\n\n    // Trim the new sides of the new root.\n    if (newRoot && newOrigin > oldOrigin) {\n      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n    }\n    if (newRoot && newTailOffset < oldTailOffset) {\n      newRoot = newRoot.removeAfter(\n        owner,\n        newLevel,\n        newTailOffset - offsetShift\n      );\n    }\n    if (offsetShift) {\n      newOrigin -= offsetShift;\n      newCapacity -= offsetShift;\n    }\n  }\n\n  if (list.__ownerID) {\n    list.size = newCapacity - newOrigin;\n    list._origin = newOrigin;\n    list._capacity = newCapacity;\n    list._level = newLevel;\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\n\nfunction getTailOffset(size) {\n  return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;\n}\n\nexport { List, emptyList };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}